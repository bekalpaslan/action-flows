import { describe, it, expect } from 'vitest';
import fs from 'fs';
import path from 'path';
import { glob } from 'glob';

const MONOREPO_ROOT = path.resolve(__dirname, '..', '..', '..', '..', '..');

/**
 * Contract Health Check Selector Validation Tests (P1)
 *
 * Verifies that CSS selectors used in health check automation scripts
 * reference documented CSS classes in the contract.
 *
 * Prevents: Health check failures due to selector drift
 * Detects: Placeholder selectors (generic UIDs like "discuss-button-flow-visualization")
 *
 * Scope: All contracts with Health Checks sections
 */

// Extract CSS classes from contract
function extractDocumentedClasses(contractContent: string): Set<string> {
  const classes = new Set<string>();
  const testHooksMatch = contractContent.match(/## Test Hooks\s+([\s\S]*?)(?=\n## |\n---|\Z)/);

  if (!testHooksMatch) {
    return classes;
  }

  const testHooksSection = testHooksMatch[1];
  const cssMatch = testHooksSection.match(/(?:CSS|Selectors|Classes).*?:\s+([\s\S]*?)(?:\n\n|\n###|\Z)/i);

  if (!cssMatch) {
    return classes;
  }

  const cssSection = cssMatch[1];
  const lines = cssSection.split('\n');

  lines.forEach((line) => {
    const listMatch = line.match(/^-\s*`\.([a-zA-Z0-9_-]+)`/);
    if (listMatch) {
      classes.add(listMatch[1]);
    }

    const inlineMatch = line.match(/`\.([a-zA-Z0-9_-]+)`/);
    if (inlineMatch) {
      classes.add(inlineMatch[1]);
    }

    const bareMatch = line.match(/^-\s*\.([a-zA-Z0-9_-]+)$/);
    if (bareMatch) {
      classes.add(bareMatch[1]);
    }
  });

  return classes;
}

// Extract selectors from health check automation scripts
function extractHealthCheckSelectors(contractContent: string): Array<{ id: string; selectors: string[] }> {
  const healthChecks: Array<{ id: string; selectors: string[] }> = [];

  // Find Health Checks section
  const healthChecksMatch = contractContent.match(/## Health Checks\s+([\s\S]*?)(?=\n## |\n---|\Z)/);

  if (!healthChecksMatch) {
    return healthChecks;
  }

  const healthChecksSection = healthChecksMatch[1];

  // Find each HC-XXX block
  const hcMatches = healthChecksSection.matchAll(/#### (HC-[A-Z0-9-]+):(.*?)(?=\n#### |\n## |\Z)/gs);

  for (const match of hcMatches) {
    const id = match[1];
    const hcContent = match[2];

    const selectors: string[] = [];

    // Look for selectors in various formats:
    // 1. .locator('.classname')
    // 2. querySelector('.classname')
    // 3. Test ID: classname
    // 4. CSS Selector: .classname

    // Format: .locator('.classname') or .locator(".classname")
    const locatorMatches = hcContent.matchAll(/\.locator\(['"]([^'"]+)['"]\)/g);
    for (const m of locatorMatches) {
      selectors.push(m[1]);
    }

    // Format: querySelector('.classname')
    const queryMatches = hcContent.matchAll(/querySelector\(['"]([^'"]+)['"]\)/g);
    for (const m of queryMatches) {
      selectors.push(m[1]);
    }

    // Format: `...` code blocks with CSS selectors
    const codeBlockMatches = hcContent.matchAll(/`([^`]*\.[-a-zA-Z0-9_]+[^`]*)`/g);
    for (const m of codeBlockMatches) {
      const block = m[1];
      const classMatches = block.matchAll(/\.([a-zA-Z0-9_-]+)/g);
      for (const cm of classMatches) {
        selectors.push(cm[1]);
      }
    }

    if (selectors.length > 0) {
      healthChecks.push({ id, selectors });
    }
  }

  return healthChecks;
}

// Detect if selector looks like a placeholder
function isPlaceholderSelector(selector: string): boolean {
  // Generic patterns that suggest placeholder selectors:
  // - all-lowercase with hyphens: "discuss-button-flow-visualization"
  // - "test-", "temp-", "placeholder-", "todo-", "mock-" prefixes
  // - numbered patterns: "element-1", "item-2"

  const lowercased = selector.toLowerCase();

  // Check for generic prefixes
  if (/^(test-|temp-|placeholder-|todo-|mock-|debug-|wip-)/.test(lowercased)) {
    return true;
  }

  // Check for overly generic compound patterns, but allow BEM notation
  // BEM uses __ (element) and -- (modifier) which are legitimate
  const isBEM = /__|--/.test(lowercased);
  if (!isBEM) {
    const parts = lowercased.split('-').filter((p) => p.length > 0);
    if (parts.length > 5) {
      // More than 5 parts without BEM notation might be generic
      return true;
    }
  }

  // Check for numeric suffixes (suggests autogenerated)
  if (/-\d+$/.test(lowercased)) {
    return true;
  }

  return false;
}

describe('Contract Health Check Selector Validation (P1)', () => {
  // Find all contracts with Health Checks
  const contractFiles = glob.sync('packages/app/src/contracts/**/*.contract.md', {
    ignore: '**/TEMPLATE.contract.md',
    cwd: MONOREPO_ROOT,
  });

  const contractsWithHealthChecks = contractFiles.filter((contractPath) => {
    const content = fs.readFileSync(path.resolve(MONOREPO_ROOT, contractPath), 'utf-8');
    return /## Health Checks/.test(content);
  });

  if (contractsWithHealthChecks.length === 0) {
    it.skip('No contracts with Health Checks section found', () => {});
    return;
  }

  contractsWithHealthChecks.forEach((contractPath) => {
    const contractName = path.basename(contractPath, '.contract.md');
    const content = fs.readFileSync(path.resolve(MONOREPO_ROOT, contractPath), 'utf-8');
    const documentedClasses = extractDocumentedClasses(content);
    const healthChecks = extractHealthCheckSelectors(content);

    describe(`${contractName} Health Checks`, () => {
      if (healthChecks.length === 0) {
        it.skip('No automation scripts found', () => {});
        return;
      }

      healthChecks.forEach(({ id, selectors }) => {
        it(`${id} uses documented or valid selectors`, () => {
          const issues: string[] = [];

          selectors.forEach((selector) => {
            // Check if it's a placeholder
            if (isPlaceholderSelector(selector)) {
              issues.push(`⚠ PLACEHOLDER SELECTOR: "${selector}" looks like autogenerated/placeholder`);
            }

            // Check if it references a documented class (without the dot)
            const className = selector.replace(/^\./, '');
            if (documentedClasses.size > 0 && !documentedClasses.has(className) && /^[a-zA-Z0-9_-]+$/.test(className)) {
              // Only flag if we have documented classes and this looks like a class name
              issues.push(
                `✗ UNDOCUMENTED SELECTOR: ".${className}" used in health check but not documented in Test Hooks`
              );
            }
          });

          if (issues.length > 0) {
            expect.fail(`${contractName}/${id} selector issues:\n${issues.join('\n')}`);
          }
        });
      });
    });
  });
});
