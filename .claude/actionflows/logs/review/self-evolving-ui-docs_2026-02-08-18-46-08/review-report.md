# Review Report: docs/FRD-SelfEvolvingUI.md, docs/SRD-SelfEvolvingUI.md

## Verdict: NEEDS_CHANGES
## Score: 70%

## Summary

The FRD and SRD for the Self-Evolving Interface are well-structured, comprehensive in scope, and demonstrate strong alignment with the existing ActionFlows Dashboard architecture. The documents cover all four feature areas (Button System, Pattern Detection, Registry Model, Self-Modification Pipeline) with detailed requirement tables, type definitions, and implementation sequences. However, there are structural inconsistencies with the existing FRD/SRD templates, several traceability gaps between FRD requirement IDs and SRD implementation steps, technical inaccuracies in how the documents reference existing codebase components, and a few feasibility concerns around the implementation estimates.

## Findings

| # | File | Line | Severity | Description | Suggestion |
|---|------|------|----------|-------------|------------|
| 1 | FRD-SelfEvolvingUI.md | 1-20 | medium | **Duplicate Executive Summary:** The document has an unnumbered "Executive Summary" section at line 12 AND a numbered "1. Executive Summary" section at line 20. The existing FRD.md uses a single unnumbered Executive Summary followed by numbered sections starting from "1. Executive Summary" -- but the content between these two sections in FRD-SelfEvolvingUI.md is redundant and duplicated. | Remove the unnumbered "Executive Summary" block (lines 12-17) and keep only the numbered "1. Executive Summary" section, matching the existing FRD.md pattern. |
| 2 | FRD-SelfEvolvingUI.md | - | medium | **Missing "Framework Philosophy" section numbering:** The existing FRD.md has Section 3 titled "Framework Philosophy" covering the delegation model, sin test, etc. The new FRD uses "3. Feature Philosophy" which diverges from the template naming convention. While the content is different (progressive autonomy vs. delegation model), the structural naming should be consistent. | Rename to "3. Feature Philosophy" is acceptable since this is a new feature area, but add a note referencing the parent FRD.md Section 3 ("Framework Philosophy") to show how Self-Evolving Interface extends the existing framework philosophy. |
| 3 | FRD-SelfEvolvingUI.md | - | high | **Missing Status Tracking:** The existing FRD.md uses status markers with emoji (checkmark/clock/construction) throughout all feature tables. FRD-SelfEvolvingUI.md only uses plain "TODO" text. While the Appendix explains this, the inconsistency means automated status parsing tools would need separate handling for the two formats. | Adopt the same status marker format as FRD.md: use "TODO" but with the construction emoji prefix (or at minimum, use a consistent marker that aligns with the existing FRD.md pattern). |
| 4 | SRD-SelfEvolvingUI.md | 171 | medium | **ButtonDefinition references `LayerSource` but `LayerSource` is defined in `registryTypes.ts`:** The `ButtonDefinition` type at line 218 imports `LayerSource` as a field (`source: LayerSource`), but `LayerSource` is specified in Section 4 (registryTypes.ts). This creates a circular dependency between button types and registry types in the shared package. | Define `LayerSource` in a separate shared utility file (e.g., `commonTypes.ts`) or in the existing `types.ts`, since it is used across multiple type definition files. Alternatively, make button types not depend on registry types and add `source` as a string union instead. |
| 5 | SRD-SelfEvolvingUI.md | 569-580 | medium | **RegistryEntry `data` field uses a plain union instead of discriminated union:** The `data: ButtonDefinition \| PatternDefinition \| ModifierDefinition` field at line 577 is not discriminated. The existing codebase consistently uses discriminated unions (e.g., events.ts uses `type` field as discriminator). A plain union makes it impossible to narrow the type without user-defined type guards. | Use a discriminated union pattern: wrap the data payload with its `type` field, e.g., `data: { type: 'button'; definition: ButtonDefinition } \| { type: 'pattern'; definition: PatternDefinition } \| { type: 'modifier'; definition: ModifierDefinition }`. This matches the existing event type pattern in events.ts. |
| 6 | SRD-SelfEvolvingUI.md | 315-316 | medium | **FrequencyRecord uses `ProjectId` but imports are not specified:** The `FrequencyRecord` interface uses `ProjectId` and `UserId` but the SRD does not mention that `ProjectId` comes from `packages/shared/src/projects.ts`. The existing codebase defines `ProjectId` in `projects.ts`, not in `types.ts`. New types should reference the correct import path. | Add an import note indicating `ProjectId` is imported from `projects.ts` and `UserId`/`Timestamp` from `types.ts`. |
| 7 | SRD-SelfEvolvingUI.md | 59 | low | **Events file extension:** The SRD says to extend `events.ts` with 8 new event types. The existing `events.ts` uses `.js` extension in imports (`from './types.js'`). While the SRD correctly identifies the file, it should note the ES module extension pattern used throughout the shared package. | Minor: Add a note that all shared imports use `.js` extensions per the ES module convention in the existing codebase. |
| 8 | FRD-SelfEvolvingUI.md | 233-234 | medium | **QuickActionBar integration claim is partially inaccurate:** The FRD states "Extends existing `QuickActionBar` component with learned actions" and that `QuickActionSettings.tsx` provides configuration UI. The actual `QuickActionBar.tsx` takes `quickActions: QuickActionDefinition[]` as a prop and is tightly coupled to `SessionId` and `SessionLifecycleState`. It is not a standalone toolbar -- it is embedded in each session tile. Extending it for global/persistent toolbar use would require significant refactoring. | Clarify that `QuickActionBar` is session-scoped (per-tile) and that the persistent toolbar is likely a NEW component that may share styling/button rendering from `QuickActionButton.tsx` but needs its own container, state management, and placement outside the session grid. |
| 9 | SRD-SelfEvolvingUI.md | 282-286 | medium | **ConversationPanel integration description oversimplified:** The SRD says InlineButtons renders "as a child of each message item in the conversation panel." However, `ConversationPanel.tsx` currently renders messages from `session.lastPrompt` and does not iterate over a full message history from events. The component is simple and focused on the most recent prompt/response. Adding inline buttons per-message requires the ConversationPanel to first be upgraded to render full conversation history. | Add a prerequisite task: "Upgrade ConversationPanel to render full message history (currently only shows lastPrompt)" before the InlineButtons integration step. This is a dependency that affects Phase 1 estimates. |
| 10 | SRD-SelfEvolvingUI.md | 970-997 | high | **Storage interface extension is breaking:** Adding ~12 new methods to the existing `Storage` interface means both `MemoryStorage` and `RedisStorage` implementations must be updated simultaneously. The existing interface has ~20 methods. Doubling the interface surface area is a high-risk change. Also, the SRD storage methods use `void \| Promise<void>` return type which matches the existing pattern -- this is correct. | Recommend using a separate `SelfEvolvingStorage` interface that extends `Storage`, or use a composition pattern (separate storage service classes that wrap the base Storage). This isolates the self-evolving feature from core storage and reduces blast radius. |
| 11 | FRD-SelfEvolvingUI.md | 497-499 | medium | **Button System prototype estimate "2-3 weeks" may be optimistic:** Given that ConversationPanel needs upgrading (finding #9), context detection needs building from scratch, and the QuickActionBar is session-scoped (finding #8), the Phase 1 estimate should account for prerequisite work. | Revise estimate to 3-4 weeks or explicitly call out the ConversationPanel upgrade as week 0 prerequisite work. |
| 12 | SRD-SelfEvolvingUI.md | 1119-1130 | low | **Critical path math inconsistency:** Section 7.3 lists 11 serial dependencies totaling ~24 working days (4.8 weeks), then says "Optimized total: ~12 weeks (5 weeks critical path + 7 weeks parallel and buffer)." But the 28-step plan in Section 7.1 already accounts for 12 weeks across 4 phases. The "5 weeks critical path" claim contradicts the "4.8 weeks" calculation above it. | Reconcile: either the critical path is 4.8 weeks (24 days) or 5 weeks (25 days). Pick one and update both references. |
| 13 | FRD-SelfEvolvingUI.md | - | high | **FRD-to-SRD traceability gaps:** Several FRD requirement IDs do not have corresponding implementation steps in the SRD. Specifically: BTN-07 (keyboard shortcuts), TBR-07 (drag-and-drop reordering), TBR-08 (usage count badge), STR-07 (export starred items), FRQ-05 (retention configuration), PAT-06 (pattern categories). These are marked LOW priority in the FRD but the SRD does not mention them at all -- not even as deferred items. | Add a "Deferred Requirements" appendix to the SRD listing all LOW-priority FRD requirements with a note that they are not included in the 12-week implementation plan. This preserves traceability. |
| 14 | SRD-SelfEvolvingUI.md | 486-495 | low | **WebSocket event types missing `eventId` from BaseEvent:** The 8 new event types defined in Section 3.6 each define their own `type`, `sessionId`, and `timestamp` fields but do not extend `BaseEvent`. The existing codebase events all extend `BaseEvent` which includes optional `eventId` and `user` fields. | New event types should extend `BaseEvent` to inherit `eventId` and `user` fields, matching the existing pattern in events.ts. |
| 15 | SRD-SelfEvolvingUI.md | 161-163 | low | **Integration table references `sessionWindows.ts`:** The table says "Toolbar state stored in SessionWindowConfig" but `SessionWindowConfig` is session-scoped (keyed by `SessionId`). Toolbar config is project-scoped or user-scoped. These are different scoping levels. | Clarify that toolbar state is stored via the new `/api/toolbar/:projectId/config` endpoint (project-scoped), not in `SessionWindowConfig`. Remove or correct the `sessionWindows.ts` reference in the integration table. |
| 16 | SRD-SelfEvolvingUI.md | 162 | low | **Integration table references `projects.ts`:** The table says "Per-project registry overrides in Project model." The existing `Project` interface in `projects.ts` has `quickActionPresets` but no field for registry overrides. Adding fields to `Project` would also extend the Storage interface (projects are stored via the projects route). | Note that extending `Project` with registry override fields is an additional Storage/API change not accounted for in the implementation steps. |
| 17 | FRD-SelfEvolvingUI.md | 207-208 | low | **Context detection mentions "existing command system" with incorrect names:** The FRD says "Actions map to existing command system (`PauseCommand`, `RetryCommand`, etc.)." The existing codebase uses `CommandType` enum with values `'pause'`, `'resume'`, etc., and the command interfaces are `PauseCommand`, `RetryCommand`, etc. This is technically correct but `ButtonAction.commandType` in the SRD uses `string` rather than `CommandTypeString` which would be the proper typed reference. | Use `CommandTypeString` (from commands.ts) as the type for `ButtonAction.commandType` instead of `string`, for type safety. |
| 18 | SRD-SelfEvolvingUI.md | 793-812 | medium | **ModificationExecutor runs pnpm commands but is a backend service:** The executor runs `pnpm type-check`, `pnpm lint`, `pnpm test` as post-modification validation. These are shell commands that would need to be spawned as child processes from the Express backend. This is architecturally unusual for a web server process and has security implications (shell injection if proposal data is not sanitized). | Add security notes about command sanitization and consider running validation in an isolated process/worker. Note the security risk explicitly in the risk assessment. |

## Fixes Applied (if mode = review-and-fix)

N/A -- mode is `review-only`.

## Flags for Human

| Issue | Why Human Needed |
|-------|-----------------|
| Storage interface extension strategy (finding #10) | Architecture decision: extend existing interface vs. composition pattern. Affects all backend code. |
| ConversationPanel prerequisite (finding #9) | Product decision: should Phase 1 include upgrading ConversationPanel to full message history, or scope InlineButtons to only the most recent response? |
| QuickActionBar scope clarification (finding #8) | Architecture decision: extend session-scoped QuickActionBar or build new persistent toolbar component? |
| Self-modification executing shell commands from Express (finding #18) | Security architecture decision: how to sandbox modification validation (pnpm commands) from the web server process. |
| Phase 1 timeline (finding #11) | Project management: revised estimate needed once prerequisite work is scoped. |
